# -
用于辅助资管办公室排班工作

好的，很高兴能为您规划这款排班App的开发。这是一个非常具体且有挑战性的需求，核心在于其复杂的排班规则和算法。下面我将为您提供一个完整的技术方案，包括技术栈推荐、架构设计、功能模块拆解和核心难点分析。

---

### **1. 整体分析与架构建议**

这个App的核心是一个**约束满足问题（Constraint Satisfaction Problem）**的求解器。对于100人左右的规模，计算量在可控范围内，完全可以在手机端完成，无需依赖服务器。因此，建议采用**纯客户端（单机）**的架构。

*   **数据流:**
    `Excel导入` -> `数据解析与预处理` -> `存入本地数据库` -> `用户配置排班规则` -> `运行排班算法` -> `生成排班结果` -> `界面展示` -> `导出为Excel`

---

### **2. 技术栈推荐 (Android Native)**

考虑到平台要求（Android 11-16）和性能要求，原生开发是最佳选择。

*   **开发语言: Kotlin**
    *   **原因:** Google官方首推的Android开发语言，语法简洁、空安全，能显著提高开发效率和代码健壮性。

*   **UI框架: Jetpack Compose**
    *   **原因:** 现代化的声明式UI框架。相比传统的XML布局，Compose能更快地构建复杂、动态的UI（如排班表），代码更少，逻辑更清晰。

*   **本地数据库: Room (Jetpack组件)**
    *   **原因:** 在SQLite上提供了一个抽象层，可以方便地将Java/Kotlin对象映射到数据库表中。编译时SQL校验，能有效避免运行时错误。非常适合存储人员信息、空闲时间、排班规则和生成的排班表。

*   **Excel文件处理: Apache POI 或 EasyExcel**
    *   **Apache POI:** 功能强大，支持读写各种版本的Excel文件（.xls, .xlsx）。但API相对复杂，包体积较大。
    *   **EasyExcel (推荐):** 阿里巴巴开源库，基于POI做了封装，API更简洁，内存占用更低，对大型Excel文件处理更友好。对于您这个场景，**EasyExcel是更好的选择**。

*   **异步处理: Kotlin Coroutines (协程)**
    *   **原因:** 文件IO（读写Excel）、数据库操作、排班算法计算都可能是耗时操作，必须在后台线程执行以避免UI卡顿。协程是Kotlin提供的轻量级线程管理方案，比传统线程和AsyncTask更易用、更高效。

*   **权限处理:**
    *   由于需要读写外部存储的Excel文件，需要处理文件访问权限。在Android 11及以上，推荐使用**存储访问框架 (Storage Access Framework, SAF)**，让用户通过文件选择器来主动授予文件访问权限，这是最规范、最安全的方式。

---

### **3. 功能模块拆解与实现思路**

#### **模块一：数据导入与解析模块**

1.  **文件选择:** 提供一个按钮，触发SAF文件选择器，让用户选择要导入的Excel表格。
2.  **Excel解析 (使用EasyExcel):**
    *   定义一个数据类（Data Class）来映射Excel的每一行，例如 `RawScheduleEntry(name: String, studentId: String, classTime: String)`。
    *   使用EasyExcel读取文件，将每一行解析到这个数据类的列表中。
3.  **数据清洗与预处理:** 这是关键一步。
    *   **合并人员信息:** Excel中同一个人（姓名+学号）有多行记录，需要将它们合并。最终的数据结构应该是 `Map<String, Person>`，其中Key是学号，Value是`Person`对象。
    *   **`Person`对象结构:**
        ```kotlin
        data class Person(
            val name: String,
            val studentId: String,
            val grade: Int, // 年级
            val unavailableSlots: Set<TimeSlot> // 没空的时间段集合
        )
        ```
    *   **解析年级:** 从学号中提取年级。你需要定义一个规则，例如学号前两位/四位代表入学年份，再通过当前年份计算出年级。例如 `24050612`，如果`24`代表2024年入学，那么就是大一。这个规则需要在App中可以配置或硬编码。
    *   **解析“上课时间” (核心难点):** 这个字符串格式复杂，需要用正则表达式或精细的字符串分割来处理。
        *   **步骤1:** 按分号 `;` 分割，得到多个上课时间段。
        *   **步骤2:** 对每一个时间段，如 `星期四第3-5节{1-17周}`，进行解析。
            *   提取星期：`星期四` -> `DayOfWeek.THURSDAY`
            *   提取节次：`第3-5节` -> `3, 4, 5`
            *   提取周次：`{1-17周}` -> `1..17`。注意处理更复杂的格式，如 `{1-7周,10-17周}`，需要先按逗号 `,` 分割再解析。
        *   **步骤3:** 将解析出的所有“没空”的时间点（(周次, 星期, 节次) 的三元组）存入`Person`对象的 `unavailableSlots` 集合中。

4.  **数据持久化:** 将处理好的`Person`列表存入Room数据库，方便后续使用。

#### **模块二：排班规则设置模块**

这个模块提供UI界面，让管理员配置排班规则。

1.  **班次定义:**
    *   提供一个列表，用户可以动态添加/删除/修改班次。
    *   每个班次包含：班次名称（可选）、星期几、开始节次、结束节次、需要人数（默认为1，可以扩展）。
    *   例如：用户可以定义 "周一早班" 为 `星期一 第1-2节`，需要2人。

2.  **年级配额设置:**
    *   动态读取所有存在的年级（从已导入的人员数据中提取）。
    *   为每个年级提供一个输入框，用于设置“每周应排班次”。

3.  **特殊规则设置:**
    *   提供一个设置项，例如一个下拉菜单和一个开关：“当年级为 [选择年级] 的人员值班时，必须有其他年级的人员在场”。

#### **模块三：核心排班算法模块**

这是整个App的大脑，需要在后台线程中运行。

1.  **算法准备阶段:**
    *   获取指定周（例如，用户选择的本周）的所有需要排班的班次（Shift）。
    *   获取所有人员信息。
    *   为每个人员计算一个“本周可用时间集合”，即用“所有可能的班次时间”减去他们的`unavailableSlots`。
    *   初始化每个人的“已安排班次数”为0。

2.  **算法核心逻辑 (推荐使用回溯算法 + 启发式搜索):**
    *   **目标:** 为所有`Shift`找到合适的人。
    *   **回溯法框架:**
        *   `function solve(shiftsToFill):`
            *   如果 `shiftsToFill` 为空，说明所有班次都排好了，返回 `true` (成功)。
            *   取出一个班次 `currentShift`。
            *   获取 `currentShift` 的候选人列表 `candidates`：
                *   候选人必须在该班次时间段内有空。
                *   **启发式排序 (关键):** 为了“尽可能平均”，对`candidates`进行排序，优先选择“已安排班次数”最少的人。
            *   遍历 `candidates` 中的每个 `person`:
                *   **检查约束:**
                    1.  **配额约束:** `person` 的“已安排班次数”是否已达到其所在年级的配额上限？如果达到则跳过。
                    2.  **特殊规则约束:** 如果 `person` 属于特殊年级，检查当前`currentShift`是否已有/能有其他年级的人。如果当前班次只招1人，则此人不能是特殊年级。如果招多人，可以先将他放入，但后续必须为该班次找到一个非特殊年级的人。这个约束会增加算法复杂度。一个简化处理是：在为特殊年级人员排班时，确保候选池里还有非该年级的人员可用。
                *   如果所有约束都满足：
                    *   将 `person` 分配给 `currentShift`。
                    *   更新 `person` 的“已安排班次数”。
                    *   **递归调用:** `if solve(remainingShifts)` 返回 `true`，则直接返回 `true`。
                    *   **回溯:** 如果递归调用返回 `false`（说明后续的路走不通了），则撤销分配（将`person`从`currentShift`中移除，恢复他的“已安排班次数”），然后尝试下一个候选人。
            *   如果所有候选人都尝试失败，返回 `false`。

3.  **结果处理与提醒:**
    *   如果算法成功找到一个解，就保存排班结果。
    *   如果在算法执行后，某些人的排班数量未达到其年级配额，记录下来，生成一条系统提醒：“XXX因时间冲突，未能排满X个班次”。
    *   如果某个班次最终无人可排，也生成提醒：“周X第Y-Z节班次无人可排”。

#### **模块四：排班结果展示与导出模块**

1.  **界面展示:**
    *   使用`LazyColumn`或`LazyVerticalGrid` (Jetpack Compose)来构建一个表格。
    *   横轴是星期一到星期日，纵轴是节次。
    *   在对应的单元格中显示被安排人员的姓名。

2.  **导出为Excel:**
    *   提供一个“导出”按钮。
    *   在后台线程中，使用EasyExcel创建一个新的Excel工作簿。
    *   将排班表的数据结构写入工作簿中，可以设置一些简单的样式（如表头加粗）。
    *   通过SAF让用户选择保存位置和文件名，然后将生成的Excel文件写入。

---

### **4. 关键挑战与解决方案**

1.  **“上课时间”字符串的解析:**
    *   **挑战:** 格式多变，如`{1-7周,10-17周}`。
    *   **方案:** 必须编写健壮的解析器。使用正则表达式是最高效的方式，可以定义匹配模式，一次性提取出星期、节次、周次等所有信息。要充分测试各种边界情况。

2.  **排班算法的性能与效果:**
    *   **挑战:** 纯粹的回溯可能会因为搜索空间巨大而耗时较长（虽然100人规模问题不大）。并且可能找不到最优解（最“平均”的解）。
    *   **方案:**
        *   **启发式搜索:** 在选择候选人时，始终优先选择当前已排班最少的人，这是一种贪心策略，可以快速趋向“平均”的结果。
        *   **约束传播:** 在分配一个人后，可以更新其他相关约束，提前排除掉不可行的后续选择，从而“剪枝”，减少搜索范围。
        *   **设置超时:** 为算法设置一个最长运行时间（如10-15秒），如果超时还未找到解，就返回一个当前最优的部分解，并提示用户“可能无法满足所有条件”。

3.  **“特殊年级必须有其他年级在场”的约束处理:**
    *   **挑战:** 这个约束是跨人员的，处理起来比较复杂。
    *   **方案:**
        *   **如果班次只招1人:** 那么这个班次的候选人池直接排除掉所有特殊年级的人。
        *   **如果班次招N人 (N>1):** 在为该班次分配第 `i` 个人时 (`1 <= i <= N`)，需要检查：如果之前 `i-1` 个人全是特殊年级的人，那么当前这个人必须是非特殊年级的。如果在分配完 `N` 个人后，发现全是特殊年级的，则此次分配方案无效，需要回溯。

### **总结**

您的需求完全可以通过一个高质量的Android App实现。核心工作量在于**数据解析**和**排班算法**这两个模块。采用`Kotlin + Jetpack Compose + Room + EasyExcel`这个技术栈，可以高效地完成开发，并保证App的性能和用户体验。建议在开发算法时，从最简单的规则开始，逐步增加约束，并进行充分的测试。